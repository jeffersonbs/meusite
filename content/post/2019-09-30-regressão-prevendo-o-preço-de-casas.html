---
title: 'Regressão: predição do preço de casas'
author: Jefferson Barbosa
date: '2019-09-30'
slug: regressão-predição-do-preço-de-casas
categories: []
tags:
  - regression
  - random forest
  - gradient boosting
---  



<h2>
Sobre os dados
</h2>
<p>Os dados utilizados aqui são provenientes da competição do <a href="kaggle.com">Kaggle</a> chamada de <a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/overview">House prices: Advanced Regression Techniques</a>. O conjunto de dados contêm 79 variáveis explicativas sobre algumas casas em Ames/Iowa. E o objetivo, claro, é o de predizer o valor de venda dessas casas.</p>
<p>Nesta publicação eu mostrarei o passo a passo da minha análise desses dados, mostrado a forma como eu limpei os dados, o feature engineering e a modelagem. Vou utilizar uma regressão linear como modelo base e irei comparar os resultados com modelos feitos com Random Forest, Stochastic Gradient Boosting e Bayesian. Regularized Neural Networks.</p>
<h2>
Processamento dos dados
</h2>
<p>Nesta etapa eu utilizarei os seguintes pacotes:</p>
<pre class="r"><code>library(dplyr)
library(naniar)
library(corrplot)
library(ggplot2)
library(randomForest)</code></pre>
<p>O conjunto de dados conta com 1460 observações e 80 variáveis explicativas.</p>
<pre class="r"><code>str(dados)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1460 obs. of  81 variables:
##  $ Id           : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ MSSubClass   : int  60 20 60 70 60 50 20 60 50 190 ...
##  $ MSZoning     : chr  &quot;RL&quot; &quot;RL&quot; &quot;RL&quot; &quot;RL&quot; ...
##  $ LotFrontage  : int  65 80 68 60 84 85 75 NA 51 50 ...
##  $ LotArea      : int  8450 9600 11250 9550 14260 14115 10084 10382 6120 7420 ...
##  $ Street       : chr  &quot;Pave&quot; &quot;Pave&quot; &quot;Pave&quot; &quot;Pave&quot; ...
##  $ Alley        : chr  NA NA NA NA ...
##  $ LotShape     : chr  &quot;Reg&quot; &quot;Reg&quot; &quot;IR1&quot; &quot;IR1&quot; ...
##  $ LandContour  : chr  &quot;Lvl&quot; &quot;Lvl&quot; &quot;Lvl&quot; &quot;Lvl&quot; ...
##  $ Utilities    : chr  &quot;AllPub&quot; &quot;AllPub&quot; &quot;AllPub&quot; &quot;AllPub&quot; ...
##  $ LotConfig    : chr  &quot;Inside&quot; &quot;FR2&quot; &quot;Inside&quot; &quot;Corner&quot; ...
##  $ LandSlope    : chr  &quot;Gtl&quot; &quot;Gtl&quot; &quot;Gtl&quot; &quot;Gtl&quot; ...
##  $ Neighborhood : chr  &quot;CollgCr&quot; &quot;Veenker&quot; &quot;CollgCr&quot; &quot;Crawfor&quot; ...
##  $ Condition1   : chr  &quot;Norm&quot; &quot;Feedr&quot; &quot;Norm&quot; &quot;Norm&quot; ...
##  $ Condition2   : chr  &quot;Norm&quot; &quot;Norm&quot; &quot;Norm&quot; &quot;Norm&quot; ...
##  $ BldgType     : chr  &quot;1Fam&quot; &quot;1Fam&quot; &quot;1Fam&quot; &quot;1Fam&quot; ...
##  $ HouseStyle   : chr  &quot;2Story&quot; &quot;1Story&quot; &quot;2Story&quot; &quot;2Story&quot; ...
##  $ OverallQual  : int  7 6 7 7 8 5 8 7 7 5 ...
##  $ OverallCond  : int  5 8 5 5 5 5 5 6 5 6 ...
##  $ YearBuilt    : int  2003 1976 2001 1915 2000 1993 2004 1973 1931 1939 ...
##  $ YearRemodAdd : int  2003 1976 2002 1970 2000 1995 2005 1973 1950 1950 ...
##  $ RoofStyle    : chr  &quot;Gable&quot; &quot;Gable&quot; &quot;Gable&quot; &quot;Gable&quot; ...
##  $ RoofMatl     : chr  &quot;CompShg&quot; &quot;CompShg&quot; &quot;CompShg&quot; &quot;CompShg&quot; ...
##  $ Exterior1st  : chr  &quot;VinylSd&quot; &quot;MetalSd&quot; &quot;VinylSd&quot; &quot;Wd Sdng&quot; ...
##  $ Exterior2nd  : chr  &quot;VinylSd&quot; &quot;MetalSd&quot; &quot;VinylSd&quot; &quot;Wd Shng&quot; ...
##  $ MasVnrType   : chr  &quot;BrkFace&quot; &quot;None&quot; &quot;BrkFace&quot; &quot;None&quot; ...
##  $ MasVnrArea   : int  196 0 162 0 350 0 186 240 0 0 ...
##  $ ExterQual    : chr  &quot;Gd&quot; &quot;TA&quot; &quot;Gd&quot; &quot;TA&quot; ...
##  $ ExterCond    : chr  &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; ...
##  $ Foundation   : chr  &quot;PConc&quot; &quot;CBlock&quot; &quot;PConc&quot; &quot;BrkTil&quot; ...
##  $ BsmtQual     : chr  &quot;Gd&quot; &quot;Gd&quot; &quot;Gd&quot; &quot;TA&quot; ...
##  $ BsmtCond     : chr  &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; &quot;Gd&quot; ...
##  $ BsmtExposure : chr  &quot;No&quot; &quot;Gd&quot; &quot;Mn&quot; &quot;No&quot; ...
##  $ BsmtFinType1 : chr  &quot;GLQ&quot; &quot;ALQ&quot; &quot;GLQ&quot; &quot;ALQ&quot; ...
##  $ BsmtFinSF1   : int  706 978 486 216 655 732 1369 859 0 851 ...
##  $ BsmtFinType2 : chr  &quot;Unf&quot; &quot;Unf&quot; &quot;Unf&quot; &quot;Unf&quot; ...
##  $ BsmtFinSF2   : int  0 0 0 0 0 0 0 32 0 0 ...
##  $ BsmtUnfSF    : int  150 284 434 540 490 64 317 216 952 140 ...
##  $ TotalBsmtSF  : int  856 1262 920 756 1145 796 1686 1107 952 991 ...
##  $ Heating      : chr  &quot;GasA&quot; &quot;GasA&quot; &quot;GasA&quot; &quot;GasA&quot; ...
##  $ HeatingQC    : chr  &quot;Ex&quot; &quot;Ex&quot; &quot;Ex&quot; &quot;Gd&quot; ...
##  $ CentralAir   : chr  &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ...
##  $ Electrical   : chr  &quot;SBrkr&quot; &quot;SBrkr&quot; &quot;SBrkr&quot; &quot;SBrkr&quot; ...
##  $ X1stFlrSF    : int  856 1262 920 961 1145 796 1694 1107 1022 1077 ...
##  $ X2ndFlrSF    : int  854 0 866 756 1053 566 0 983 752 0 ...
##  $ LowQualFinSF : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ GrLivArea    : int  1710 1262 1786 1717 2198 1362 1694 2090 1774 1077 ...
##  $ BsmtFullBath : int  1 0 1 1 1 1 1 1 0 1 ...
##  $ BsmtHalfBath : int  0 1 0 0 0 0 0 0 0 0 ...
##  $ FullBath     : int  2 2 2 1 2 1 2 2 2 1 ...
##  $ HalfBath     : int  1 0 1 0 1 1 0 1 0 0 ...
##  $ BedroomAbvGr : int  3 3 3 3 4 1 3 3 2 2 ...
##  $ KitchenAbvGr : int  1 1 1 1 1 1 1 1 2 2 ...
##  $ KitchenQual  : chr  &quot;Gd&quot; &quot;TA&quot; &quot;Gd&quot; &quot;Gd&quot; ...
##  $ TotRmsAbvGrd : int  8 6 6 7 9 5 7 7 8 5 ...
##  $ Functional   : chr  &quot;Typ&quot; &quot;Typ&quot; &quot;Typ&quot; &quot;Typ&quot; ...
##  $ Fireplaces   : int  0 1 1 1 1 0 1 2 2 2 ...
##  $ FireplaceQu  : chr  NA &quot;TA&quot; &quot;TA&quot; &quot;Gd&quot; ...
##  $ GarageType   : chr  &quot;Attchd&quot; &quot;Attchd&quot; &quot;Attchd&quot; &quot;Detchd&quot; ...
##  $ GarageYrBlt  : int  2003 1976 2001 1998 2000 1993 2004 1973 1931 1939 ...
##  $ GarageFinish : chr  &quot;RFn&quot; &quot;RFn&quot; &quot;RFn&quot; &quot;Unf&quot; ...
##  $ GarageCars   : int  2 2 2 3 3 2 2 2 2 1 ...
##  $ GarageArea   : int  548 460 608 642 836 480 636 484 468 205 ...
##  $ GarageQual   : chr  &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; ...
##  $ GarageCond   : chr  &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; &quot;TA&quot; ...
##  $ PavedDrive   : chr  &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ...
##  $ WoodDeckSF   : int  0 298 0 0 192 40 255 235 90 0 ...
##  $ OpenPorchSF  : int  61 0 42 35 84 30 57 204 0 4 ...
##  $ EnclosedPorch: int  0 0 0 272 0 0 0 228 205 0 ...
##  $ X3SsnPorch   : int  0 0 0 0 0 320 0 0 0 0 ...
##  $ ScreenPorch  : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ PoolArea     : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ PoolQC       : chr  NA NA NA NA ...
##  $ Fence        : chr  NA NA NA NA ...
##  $ MiscFeature  : chr  NA NA NA NA ...
##  $ MiscVal      : int  0 0 0 0 0 700 0 350 0 0 ...
##  $ MoSold       : int  2 5 9 2 12 10 8 11 4 1 ...
##  $ YrSold       : int  2008 2007 2008 2006 2008 2009 2007 2009 2008 2008 ...
##  $ SaleType     : chr  &quot;WD&quot; &quot;WD&quot; &quot;WD&quot; &quot;WD&quot; ...
##  $ SaleCondition: chr  &quot;Normal&quot; &quot;Normal&quot; &quot;Normal&quot; &quot;Abnorml&quot; ...
##  $ SalePrice    : int  208500 181500 223500 140000 250000 143000 307000 200000 129900 118000 ...</code></pre>
<p>Olhando a descrição dos dados, vi que em algumas variáveis foi atribuido NA quando o elemento não estava presente. Irei alterar para uma string, tornando assim as observações úteis para a análise.</p>
<pre class="r"><code>#Alley
dados$Alley[which(is.na(dados$Alley))] = &quot;Naa&quot;

#Basement
dados$BsmtQual[which(is.na(dados$BsmtQual))] = &quot;Nb&quot;
dados$BsmtCond[which(is.na(dados$BsmtCond))] = &quot;Nb&quot;
dados$BsmtExposure[which(is.na(dados$BsmtExposure))] = &quot;Nb&quot;
dados$BsmtFinType1[which(is.na(dados$BsmtFinType1))] = &quot;Nb&quot;
dados$BsmtFinType2[which(is.na(dados$BsmtFinType2))] = &quot;Nb&quot;

#Fireplace
dados$FireplaceQu[which(is.na(dados$FireplaceQu))] = &quot;Nf&quot;

#Garage
dados$GarageType[which(is.na(dados$GarageType))] = &quot;Ng&quot;
dados$GarageFinish[which(is.na(dados$GarageFinish))] = &quot;Ng&quot;
dados$GarageQual[which(is.na(dados$GarageQual))] = &quot;Ng&quot;
dados$GarageCond[which(is.na(dados$GarageCond))] = &quot;Ng&quot;

#Pool
dados$PoolQC[which(is.na(dados$PoolQC))] = &quot;Np&quot;

#Fence
dados$Fence[which(is.na(dados$Fence))] = &quot;Nf&quot;</code></pre>
<p>O mesmo foi feito com a variável que indica o ano de construção da garagem. Então nestes casos irei atribuir 0.</p>
<pre class="r"><code>dados$GarageYrBlt[which(is.na(dados$GarageYrBlt))] = 0</code></pre>
<p>As variáveis que indicam a identificação da casa, o mês, ano, tipo e condições da venda não serão uteis para a análise, então irei removê-las.</p>
<pre class="r"><code>dados &lt;- dados %&gt;%
  select(-c(MoSold, YrSold, SaleType, SaleCondition, Id))</code></pre>
<p>O gráfico abaixo mostra a porcentagem de NA’s em cada variável.</p>
<pre class="r"><code>gg_miss_var(dados, show_pct = T) +
  labs(x = &quot;Variáveis&quot;,y = &quot;Porcentagem de NA&quot;)</code></pre>
<p><img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-7-1.png" width="672" />
Irei remover a variável com mais de 20% de NA.</p>
<pre class="r"><code>dados &lt;- dados %&gt;%
  select(-c(MiscFeature))</code></pre>
<p>Vou imputar a categoria mais frequente ou a mediana das observações, caso seja numerica, nas demais variáveis.</p>
<pre class="r"><code>#Convertendo as strings em fatores 
#Encontra as colunas que possuem string
ind &lt;- sapply(dados, is.character)
#Converte para fator
dados[ind] &lt;- lapply(dados[ind], factor)

#Imputando dados- para a categoria mais frequente ou para a mediana caso numerico
dados &lt;- na.roughfix(dados)</code></pre>
<p>E agora não há mais NA’s nos dados.</p>
<pre class="r"><code>gg_miss_var(dados, show_pct = T) +
  labs(x = &quot;Variáveis&quot;,y = &quot;Porcentagem de NA&quot;)</code></pre>
<img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-10-1.png" width="672" />
<h3>
Feature engineering
</h3>
<p>Aqui irei criar algumas novas variáveis e aplicar algumas transformações para corrigir alguns problemas na distribuição das mesmas.</p>
<p>Para começar irei criar uma variável com o total de banheiros na casa</p>
<pre class="r"><code>dados &lt;- dados %&gt;%
  mutate(bathrooms = BsmtFullBath + 0.5*BsmtHalfBath + FullBath + 0.5*HalfBath) %&gt;%
  select(-c(BsmtFullBath, BsmtHalfBath, FullBath, HalfBath))</code></pre>
<p>e uma para a área total da casa.</p>
<pre class="r"><code>dados &lt;- dados %&gt;%
  mutate(TotalSF = X1stFlrSF + X2ndFlrSF + TotalBsmtSF) %&gt;%
  select(-c(X1stFlrSF, X2ndFlrSF, TotalBsmtSF))</code></pre>
<p>A distribuição da variável resposta SalePrice é bastante assimétrica à direita</p>
<pre class="r"><code>ggplot(dados, aes(x = SalePrice)) + 
  geom_density() + theme_bw()</code></pre>
<p><img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>E comparando os quantis da distribuição de SalePrice com os quantis teóricos da distribuição normal, podemos ver que a variável foge bastante da hipótese de normalidade.</p>
<pre class="r"><code>ggplot(dados, aes(sample = SalePrice)) +
  geom_qq() + geom_qq_line() + theme_bw()</code></pre>
<p><img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>O logaritmo natural parece amenizar bastante o problema da assimetria.</p>
<pre class="r"><code>ggplot(dados, aes(x = log(SalePrice))) + 
  geom_density() + theme_bw()</code></pre>
<p><img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-15-1.png" width="672" />
Mas a variável ainda não se adequa a distribuição normal, o que não é um problema para os métodos que irei utilizar.</p>
<pre class="r"><code>ggplot(dados, aes(sample = log(SalePrice))) + 
  geom_qq() + geom_qq_line() + theme_bw()</code></pre>
<p><img src="/post/2019-09-30-regress%C3%A3o-prevendo-o-pre%C3%A7o-de-casas_files/figure-html/unnamed-chunk-16-1.png" width="672" />
Portanto, manterei a transformação.</p>
<pre class="r"><code>dados &lt;- dados %&gt;%
  mutate(SalePrice = log(SalePrice))</code></pre>
<p>Abaixo é mostrado o coeficiente de assmimetria para as demais variáveis numéricas. Algumas delas possuem assimetrias bastante significativas e será necessário aplicar uma transformação para corrigir isto.</p>
<pre class="r"><code>psych::skew(select_if(dados, is.numeric))</code></pre>
<p>Como essas variáveis possuem zeros ou valores negativos, não será possível aplicar o logaritmo natural como foi com SalePrice, então aplicarei a raiz cúbica de toda variável com assimetria menor que -0.75 ou maior que 0.75.</p>
<pre class="r"><code>ind &lt;- sapply(dados, is.numeric)
for(i in 1:ncol(dados)){
  if(ind[i]){
    if(psych::skew(dados[,i])&gt;0.75 | psych::skew(dados[,i]) &lt; -0.75){
      dados[,i] = (dados[,i])^(1/3)
    }
  }
}</code></pre>
<p>O que produziu bons resultados.</p>
<pre class="r"><code>psych::skew(select_if(dados, is.numeric))</code></pre>
<h2>
Modelagem
</h2>
<p>Para começar vou dividir os dados em um conjunto de treino, que corresponderá a 80% das observações, e um conjunto de validação com o restante.</p>
<pre class="r"><code>set.seed(576)
index = sample(1:dim(dados)[1], 1168, replace = F)
treino = dados[index,]
validacao = dados[-index,]</code></pre>
